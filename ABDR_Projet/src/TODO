TODO : 

- fusion de catégories le temps d'une transaction multiclé

- la migration doit ne pas utiliser les transactions pour éviter les problèmes d'exception si transaction trop grosse


- détecter la surcharge/qu'on ne fait rien

- benchmark



################# réflexions

- 2 types de migration : 
	- migration forcée (transaction multiclé)
		- un kvdb demande au moniteur, la migration de target vers lui
	- migration de répartition de charge
		- un kvdb ajoute au jeton ce dont il n'a pas besoin (noms de catégories)
		- le propriétaire du jeton demande la migration vers lui des catégories dans jeton aux moniteurs concernés

	- avec cette façon de procéder, les 2 types de migrations utilisent le même système pour migrer

- initiation de migration : 
	- le kvdb qui veut faire une migration prévient le moniteur ayant la ressource 
		de la volonté de migration
	- le moniteur attend la fin des transactions impliquant 
		la ressource + bloque les nouveaux
			- cela peut se faire via un verroux de type lecteur/écrivain, 
				les threads clients sont des lecteurs, et le moniteur un ecrivain
			- cela implique un verroux lecteur écrivain par catégorie
		+ maj de qui a quoi dans le moniteur
		+ le moniteur répond au kvdb voulant la ressource en lui 
			donnant le kvdb ayant la ressource
	- le kvdb fait migration + notifie le moniteur
	- le moniteur réouvre les vannes de requetes


- tout ça nécéssite les informations suivantes : 
	- quel type de clé va avec quel autre (pour les transactions)
	- on extrait ainsi plusieurs grappes de catégories qui sont régulièrement ensemble
	- lors de la migration de répartition de charge, on donne un ensemble de grappe peu utilisé
	

//envoyer mon token
//envoyer les autres token
//si j'ai beaucoup de travail et des token, je me sert
//si mon token est revenu, je check son contenu




Problèmes : 
	- lors de multiple transactions multiclé : 
		- risque de demander plusieurs fois les profiles aux moniteurs concernés
		- la premiere fois justifiée
		- les autres fois il ne faut pas faire de migration
			- devrait quand même marcher, mais if faut un check avant de faire la 
				migration si c'est this

localProfiles : 
	- est accédé + édité lors des migrations
		- les migrations sont faits par forçage
		- ou par transaction multiclé

		-> il faut donc un mutex pour s'assurer de la cohérence
			- on peut le faire via un verroux de type lecteur/écrivain
		-> on peut continuer à utiliser le concurrenthashmap

transaction multiclé : 
	pendant la procédure de fusion transaction fission : 
		- on ne veut pas qu'il y ait des transactions dessus
		- cela n'arrive pas pour les profils migrés de par la nature lecteur/ecrivain
			qui lock les nouvelles transactions
			
		- on pourrait utiliser le même stratagème pour les profils locaux
			- readerwriter pour tous les profils locaux
			- read pour les transactions normales
			- write pour les transactions de fusion











